---
#title: "Model Training"
#author: "Aleksander Dietrichson, PhD"
crossref:
  chapters: true
#monobackgroundcolor: "lightgrey"
format: html
---

```{r}
#| include: false
library(xmas3)
library(ggdark)
library(ReinforcementLearning)
library(dplyr)
library(ggplot2)
theme_set(dark_theme_bw())
.nf <- function(x){format(x,big.mark=",")}
```

# Model Training {#sec-model-training}

Based on prior notes and analysis it seems reasonable to assume that we should be able to train an RL model on several grid sizes. We will start with the smallest sizes and work our way up, considering the actual magnitude of the combinations, which rise rapidly:

-   For 3x3 \|S\| = $2^{3\times3}$ =`r 2^(3*3) |> .nf()`
-   For 3x4 \|S\| = $2^{3\times4}$ =`r 2^(3*4) |> .nf()`
-   For 3x5 \|S\| = $2^{3\times5}$ =`r 2^(3*5) |> .nf()`
-   For 4x4 \|S\| = $2^{4\times4}$ =`r 2^(4*4) |> .nf()`
-   For 3x6 \|S\| = $2^{3\times6}$ =`r 2^(3*6) |> .nf()`
-   For 4x5 \|S\| = $2^{4\times5}$ =`r 2^(4*5) |> .nf()`
-   For 4x6 \|S\| = $2^{4\times5}$ =`r 2^(4*6) |> .nf()`
-   For 5x5 \|S\| = $2^{5\times5}$ =`r 2^(5*5) |> .nf()`

It also seems that chess-like notation, which is more human readable, and thus more convenient for the researcher (i.e. me), adds minimal overhead in the parsing and scoring processes.

## Functions Needed

For the purposes of setting up the agent training for an $m\times{n}$ board, we implemented the following functions.

### create_state_space

```{r}
#| echo: true
#| eval: false
#| code-fold: true
#| code-block-border-left: true
create_state_space <- \(nrow=3, ncol=3){
  classname <- paste0(nrow,"x",ncol,".space")
  S <- 0:(2^(ncol*nrow)-1)
  purrr::map(S,~{
   xmas3board(.x,dims = c(nrow,ncol))
  })
}
```

This function returns a list of integers with the appropriate class (mostly for printing and debugging.)

### create_action_space

This function generates an action space in chess notation given a grid on ncol and nrows.

```{r}
#| echo: true
#| eval: false
#| code-fold: true
#| code-block-border-left: true


create_action_space <-\(nrows=3, ncols=3){
  my_cols <- LETTERS[1:ncols]
  my_rows <- 1:nrows
  A <- c()
  # Vertical moves
  for(.r in 1:(length(my_rows))){
    for(.c in 1:(length(my_cols)-1)){
      A <- c(A,
             paste0(
               my_cols[.c],my_rows[.r],
               " to ",
               my_cols[.c+1],my_rows[.r]
             )
      )
    }
  }
  
  # Horizontal
  for(.c in 1:(length(my_cols))){
    for(.r in 1:(length(my_rows)-1)){
      A <- c(A,
             paste0(
               my_cols[.c],my_rows[.r],
               " to ",
               my_cols[.c],my_rows[.r+1]
             )
      )
    }
  }
  c(A,"Pass")
}

```

### make_move

This function takes as input a board B and a *move* (in chess notation). It makes the move and returns the resulting board.

```{r}
#| echo: true
#| eval: false
#| code-fold: true
#| code-block-border-left: true

make_move <- \(B, move){
  
  # If no move is made the board remains unaltered
  if(move == "Pass") return(B) 
  
  # Parse out move
  M <- as.matrix(B)
  m <- parse_move(move)
  r1<-m$rs[1];r2<-m$rs[2];c1<-m$cs[1];c2<-m$cs[2]
  tmp <- M[r2,c2]
  M[r2, c2] <- M[r1,c1]
  M[r1, c1] <- tmp
  M |>  adana::bin2int() |>
    xmas3board(dims =attr(B, "dims") )
  
}
```

### score_binary_board

This function takes as input a binary matrix and calculates the resulting score according to the rules of X-mas-3.

```{r}
#| echo: true
#| eval: false
#| code-fold: true
#| code-block-border-left: true

score_binary_board <-\(B){
  if(!is.matrix(B)) B <- as.matrix(B)
  
  # Magic numbers here are:
  # 7,14,28 - three in a row/col
  # 15, 30 - four in a row/col
  # 31 - five in a row
  rows <- 
    apply(B,1,function(x){
      v <- paste0(x, collapse = "")
      strtoi(v,2)
    })
  
  cols <- 
    apply(B,2,function(x){
      v <- paste0(x, collapse = "")
      strtoi(v,2)
    })
  
  totals <- c(cols,rows)
  
  score <- sum(
             sum(totals%in%c(7,14,28))*50,
             sum(totals%in%c(15,30))*100, 
             sum(totals%in%c(31))*200
             )
  score
}

```

These functions will allow us to create the input needed to train a *Reinforcement Learning* (RL) model.

## Procedure

We will attempt to train models for each of the grid-sized mentioned above. However, it is likely that not all sizes will converge. In fact, our prediction is that we will not make it past 3x6 \~ 6x3.

{{< include model-the-3x3-board.qmd >}}

{{< include model-the-3x4-board.qmd >}}

## Training above 3x4

We followed the same procedure as in the previous cases with similar results. As predicted the last model to converge was the one for the 3x6 grid. This took approximately 4 hours.
