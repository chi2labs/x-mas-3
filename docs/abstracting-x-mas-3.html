<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Aleksander Dietrichson, PhD">

<title>Abstracting x-mas-3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="abstracting-x-mas-3_files/libs/clipboard/clipboard.min.js"></script>
<script src="abstracting-x-mas-3_files/libs/quarto-html/quarto.js"></script>
<script src="abstracting-x-mas-3_files/libs/quarto-html/popper.min.js"></script>
<script src="abstracting-x-mas-3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="abstracting-x-mas-3_files/libs/quarto-html/anchor.min.js"></script>
<link href="abstracting-x-mas-3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="abstracting-x-mas-3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="abstracting-x-mas-3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="abstracting-x-mas-3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="abstracting-x-mas-3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Abstracting x-mas-3</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Aleksander Dietrichson, PhD </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<p>In order to analyze <em>x-mas-3</em> and training an AI to play the game, we decided to make an <em>abstract</em> version in the game in R/C++. The abstracted version is more suitable for computer-game interaction as it will communicate only the relevant information between the agent and the game. This will be substantially faster than interacting with the UI and allow for more streamlined training process.</p>
<section id="abstraction-of-the-board-and-tiles" class="level2">
<h2 class="anchored" data-anchor-id="abstraction-of-the-board-and-tiles">Abstraction of the Board and Tiles</h2>
<p>The board is a 6 by 10 grid each containing a tile out of ten different tile-types. For our purposes we represent the board as a 6x10 matrix with the letters A through J representing the ten different tiles. An example board would me represented thus:</p>
<span class="math display">\[\begin{bmatrix} G &amp; C &amp; J &amp; D &amp; G &amp; G &amp; C &amp; G &amp; B &amp; A \\ I &amp; D &amp; E &amp; A &amp; C &amp; B &amp; H &amp; C &amp; E &amp; F \\ J &amp; C &amp; J &amp; F &amp; C &amp; J &amp; A &amp; H &amp; B &amp; F \\ H &amp; C &amp; D &amp; F &amp; C &amp; F &amp; D &amp; B &amp; G &amp; B \\ D &amp; I &amp; H &amp; I &amp; I &amp; B &amp; F &amp; C &amp; C &amp; E \\ B &amp; F &amp; A &amp; J &amp; E &amp; H &amp; I &amp; C &amp; H &amp; G \end{bmatrix}\]</span>
<section id="checking-for-combinations" class="level3">
<h3 class="anchored" data-anchor-id="checking-for-combinations">Checking for Combinations</h3>
<p>Using this structure we can check for the presence of combinations using regular expressions. Using</p>
<p><span class="math display">\[
\text{([A-J])\\1\\1+}
\]</span></p>
<p>as a regular expression will identify three or more consecutive occurrences of similar tiles. Implemented in R below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>get_n_combinations <span class="ot">&lt;-</span> <span class="cf">function</span>(m){</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  my_regex <span class="ot">&lt;-</span> <span class="st">"([A-J])</span><span class="sc">\\</span><span class="st">1</span><span class="sc">\\</span><span class="st">1+"</span>  </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    rowmatch <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map_lgl</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>,<span class="sc">~</span>{</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    my_str <span class="ot">&lt;-</span> stringr<span class="sc">::</span><span class="fu">str_c</span>(m[.x,], <span class="at">collapse =</span> <span class="st">""</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">grepl</span>(my_regex,my_str) </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  colmatch <span class="ot">&lt;-</span>purrr<span class="sc">::</span><span class="fu">map_lgl</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>,<span class="sc">~</span>{</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">grepl</span>(my_regex,stringr<span class="sc">::</span><span class="fu">str_c</span>(m[,.x], <span class="at">collapse =</span> <span class="st">""</span>)) </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sum</span>(colmatch,rowmatch)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="fu">get_n_combinations</span>(board)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1</code></pre>
</div>
</div>
<p>In this case one match is returned because of the triple “C”s found in column 5.</p>
</section>
<section id="initial-board-state" class="level3">
<h3 class="anchored" data-anchor-id="initial-board-state">Initial Board State</h3>
<p>Since the initial state of the board cannot include any scoring combination we need a function that generated a random</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>initialize_board <span class="ot">&lt;-</span> <span class="cf">function</span>(){</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  tiles <span class="ot">&lt;-</span> LETTERS[<span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a> board <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="at">data =</span> <span class="fu">sample</span>(tiles,<span class="dv">60</span>,<span class="at">replace =</span> <span class="cn">TRUE</span>),<span class="dv">6</span>,<span class="dv">10</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="do">## If the initial state scores, generate another one</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">get_n_combinations</span>(board)<span class="sc">&gt;</span><span class="dv">0</span>){</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    board <span class="ot">&lt;-</span> <span class="fu">initialize_board</span>()</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a> board</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="fu">initialize_board</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
[1,] "F"  "I"  "G"  "G"  "J"  "A"  "C"  "B"  "G"  "G"  
[2,] "B"  "F"  "I"  "I"  "E"  "G"  "F"  "G"  "C"  "D"  
[3,] "G"  "F"  "G"  "D"  "H"  "I"  "E"  "E"  "B"  "H"  
[4,] "F"  "H"  "H"  "J"  "J"  "D"  "D"  "E"  "C"  "E"  
[5,] "I"  "G"  "I"  "I"  "G"  "B"  "J"  "G"  "E"  "C"  
[6,] "B"  "J"  "E"  "A"  "I"  "H"  "I"  "I"  "B"  "G"  </code></pre>
</div>
</div>
</section>
<section id="making-moves" class="level3">
<h3 class="anchored" data-anchor-id="making-moves">Making moves</h3>
<p>Moves are made by specifying a cell, and one of four directions: up, down, left, right. We can implement this thus:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>move <span class="ot">&lt;-</span> <span class="cf">function</span>(board,<span class="at">.r=</span><span class="dv">1</span>,<span class="at">.c=</span><span class="dv">1</span>,<span class="at">move=</span><span class="fu">c</span>(<span class="st">"U"</span>,<span class="st">"D"</span>,<span class="st">"L"</span>,<span class="st">"R"</span>)){</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  my_tile <span class="ot">&lt;-</span> board[.r,.c]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  target_row <span class="ot">&lt;-</span> <span class="cf">switch</span> (move,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"U"</span> <span class="ot">=</span> .r<span class="dv">-1</span>,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"D"</span> <span class="ot">=</span> .r<span class="sc">+</span><span class="dv">1</span>,</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>                        .r</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>  target_col <span class="ot">&lt;-</span> <span class="cf">switch</span> (move,</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"L"</span> <span class="ot">=</span> .c<span class="dv">-1</span>,</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                        <span class="st">"R"</span> <span class="ot">=</span> .c<span class="sc">+</span><span class="dv">1</span>,</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                        .c</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># If the move is illegal return board as is</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(target_row <span class="sc">==</span> <span class="dv">0</span>) <span class="fu">return</span>(board)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(target_row <span class="sc">&gt;</span> <span class="fu">dim</span>(board)[<span class="dv">1</span>]) <span class="fu">return</span>(board)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(target_col<span class="sc">==</span><span class="dv">0</span>) <span class="fu">return</span>(board)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(target_col <span class="sc">&gt;</span> <span class="fu">dim</span>(board)[<span class="dv">2</span>]) <span class="fu">return</span>(board)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>  board[.r,.c] <span class="ot">&lt;-</span> board[target_row,target_col]</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>  board[target_row,target_col] <span class="ot">&lt;-</span> my_tile</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>  board</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="applying-reinforcement-learning" class="level2">
<h2 class="anchored" data-anchor-id="applying-reinforcement-learning">Applying Reinforcement Learning</h2>
<p>Reinforcement Learning (RL) is an algorithm that allows an agent (i.e.&nbsp;AI) to interact with an environment over a sequence of observations. The agent seeks to be rewarded and for the reward to be maximized over time. The model consists of a set of environment states <span class="math inline">\(S\)</span> a set of actions <span class="math inline">\(A\)</span> and a set of rewards <span class="math inline">\(R\)</span> (positive or negative).</p>
<p>The algorithm is guaranteed to converge to an optimal policy for each possible state in <span class="math inline">\(S\)</span>. RL (and in this case we will use Q-learning) needs to be trained on a set of state-transition tuples formally defined thus:</p>
<p><span id="eq-tuples"><span class="math display">\[
(s_i, a_i, r_{i+1}, s_{i+1})
\tag{1}\]</span></span></p>
<p>where:</p>
<ul>
<li><span class="math inline">\(s_i\)</span> is the current environment state,</li>
<li><span class="math inline">\(a_i\)</span> is selected action in the current state,</li>
<li><span class="math inline">\(r_{i+1}\)</span> represents the reward, and,</li>
<li><span class="math inline">\(s_{i+1}\)</span> is the resulting state.</li>
</ul>
<section id="specifying-our-spaces" class="level3">
<h3 class="anchored" data-anchor-id="specifying-our-spaces">Specifying our Spaces</h3>
<p>For <span class="math inline">\(S\)</span> we have ten possibilities for each of the 60 (<span class="math inline">\(6\times10\)</span>) cells on our board. For <span class="math inline">\(A\)</span> the agent can make one out of four moves in each of the 60 cells (ignoring for the moment the marginal cases of moving off the board, which is not possible). As for the reward space <span class="math inline">\(R\)</span>, we can set this to a binary <span class="math inline">\([1,-1]\)</span>.</p>
</section>
<section id="reducing-our-spaces" class="level3">
<h3 class="anchored" data-anchor-id="reducing-our-spaces">Reducing our Spaces</h3>
<p>For our <span class="math inline">\(S\)</span> as defined above the number of possible states is <span class="math inline">\(10^{60}\)</span>, which is a 1 followed by 60 zeros. The action space <span class="math inline">\(A\)</span> is slightly smaller since there are only four possibilities for each cell, so we have “only” <span class="math inline">\(4^60\)</span> which is roughly equal to <span class="math inline">\(1.329\times10^36\)</span>.</p>
<p>Given the magnitude of these numbers it is clear that we cannot reasonably expect the algorithm to converge for several millennia with the computing power currently available. We therefore need to employ some strategies for reducing the spaces.</p>
<section id="one-type-at-a-time" class="level4">
<h4 class="anchored" data-anchor-id="one-type-at-a-time">One Type at a Time</h4>
<p>We can consider a one-type-at-a-time strategy. The heuristic implemented would then be to first look for moves involving <em>candy</em>, then move on to <em>trees</em> and so on. For example: staring with an initial board like this:</p>
<span class="math display">\[\begin{bmatrix} G &amp; C &amp; J &amp; D &amp; G &amp; G &amp; C &amp; G &amp; B &amp; A \\ I &amp; D &amp; E &amp; A &amp; C &amp; B &amp; H &amp; C &amp; E &amp; F \\ J &amp; C &amp; J &amp; F &amp; C &amp; J &amp; A &amp; H &amp; B &amp; F \\ H &amp; C &amp; D &amp; F &amp; C &amp; F &amp; D &amp; B &amp; G &amp; B \\ D &amp; I &amp; H &amp; I &amp; I &amp; B &amp; F &amp; C &amp; C &amp; E \\ B &amp; F &amp; A &amp; J &amp; E &amp; H &amp; I &amp; C &amp; H &amp; G \end{bmatrix}\]</span>
<p>And chose to consider the “A” cells we get:</p>
<span class="math display">\[\begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \end{bmatrix}\]</span>
<p>This reduces the problem to a binary one and we effectively reduce <span class="math inline">\(S\)</span> to <span class="math inline">\(2^{60}\)</span>, which is <em>merely</em> 1.15 quintillions. While this represents a huge reduction, it is still far from being feasible. In addition this does not reduce our action space <span class="math inline">\(A\)</span>, as you still have four possible moves for each of the 60 cells.</p>
</section>
<section id="windowing" class="level4">
<h4 class="anchored" data-anchor-id="windowing">Windowing</h4>
<p>We can further reduce our problem space by applying a technique knows as <em>windowing</em>. This implies dividing the grid into sub-grids and looking for playable moves within that reduced space. If we first consider the quest for a three-tile combinations, the windows in question would be a <span class="math inline">\(3\times2\)</span> and a <span class="math inline">\(2\times3\)</span> sub-matrix for perpendicular (<span class="math inline">\(\perp\)</span>)moves. For parallel (<span class="math inline">\(\parallel\)</span>) moves, i.e.&nbsp;moves with the same row or column we would have to consider and <span class="math inline">\(4\times1\)</span> respectively. Examples are shown below.</p>
<span class="math display">\[\begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 \end{bmatrix}
%
\text{ or}
%
\begin{bmatrix} 1 &amp; 0 \\ 1 &amp; 1 \\ 0 &amp; 1 \end{bmatrix}
%
\text{ for }\perp\text{moves,}\]</span>
<p>and</p>
<span class="math display">\[\begin{bmatrix} 1 &amp; 1 &amp; 0 &amp; 1 \end{bmatrix}
%
\text{ or}
%
\begin{bmatrix} 1 \\ 1 \\ 0 \\ 1 \end{bmatrix}
%
\text{ for }\parallel \text{ moves.}\]</span>
<p>Is it easy to see that the <span class="math inline">\(3\times2\)</span> matrix above is a transposition of the <span class="math inline">\(2\times3\)</span> one, and therefore it does not matter whether a move if horizontal or vertical the problem is similar in nature for all <em>perpendicular</em> moves. The same is true for the <span class="math inline">\(4\times1\)</span> and <span class="math inline">\(1\times4\)</span> matrices, i.e.&nbsp;where there is a winning <em>parallel</em> move. Matrix <a href="#eq-example-windows">2</a> illustrates two windows on our original board and Matrix <a href="#eq-example-windows-binary">3</a> shows the same in our binary space (combining the two reduction strategies).</p>
<p><span id="eq-example-windows"><span class="math display">\[
\begin{bmatrix} G &amp; \color{red}{\textbf{C}} &amp; \color{red}{\textbf{J}} &amp; \color{red}{\textbf{D}} &amp; \color{red}{\textbf{G}} &amp; G &amp; C &amp; G &amp; B &amp; A \\ I &amp; D &amp; E &amp; A &amp; C &amp; B &amp; H &amp; C &amp; E &amp; F \\ J &amp; C &amp; J &amp; F &amp; C &amp; J &amp; \color{red}{\textbf{A}} &amp; \color{red}{\textbf{H}} &amp; B &amp; F \\ H &amp; C &amp; D &amp; F &amp; C &amp; F &amp; \color{red}{\textbf{D}} &amp; \color{red}{\textbf{B}} &amp; G &amp; B \\ D &amp; I &amp; H &amp; I &amp; I &amp; B &amp; \color{red}{\textbf{F}} &amp; \color{red}{\textbf{C}} &amp; C &amp; E \\ B &amp; F &amp; A &amp; J &amp; E &amp; H &amp; I &amp; C &amp; H &amp; G \end{bmatrix}
\tag{2}\]</span></span></p>
<p><span id="eq-example-windows-binary"><span class="math display">\[
\begin{bmatrix}
0 &amp; \color{red}{\textbf{1}} &amp; \color{red}{\textbf{0}} &amp; \color{red}{\textbf{0}} &amp; \color{red}{\textbf{0}} &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \color{red}{\textbf{0}} &amp; \color{red}{\textbf{0}} &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \color{red}{\textbf{0}} &amp; \color{red}{\textbf{0}} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \color{red}{\textbf{0}} &amp; \color{red}{\textbf{1}} &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0
\end{bmatrix}
\tag{3}\]</span></span></p>
</section>
<section id="the-reduced-action-spaces" class="level4">
<h4 class="anchored" data-anchor-id="the-reduced-action-spaces">The Reduced Action Spaces</h4>
<p>If we employ the windowed approach suggested above, our action space, <span class="math inline">\(A\)</span> shrinks significantly. We will in fact have two different <span class="math inline">\(S\)</span> and <span class="math inline">\(A\)</span> depending on whether we are considering parallel or perpendicular moves.</p>
<p>For a parallel window, we can generalize to the horizontal variant (since the horizontal one is a simple transposition thereof) and we then get only a few relevant combinations. Since any four element set which already has three in a row is will not occur, we are left with: {0000,0001,0010,0011,0100,0101,0110,1000,1001,1011, 1101} for a total of 11 cases out of which only two have a winning move ({1011, 1101}). This reduces <span class="math inline">\(A_{\parallel}\)</span> for <span class="math inline">\(S_{\parallel}\)</span> to three moves: pass (P), flip first (FF) or flip last (FL). formalized in <a href="#eq-action-space-parallel">Equation&nbsp;4</a>.</p>
<p><span id="eq-action-space-parallel"><span class="math display">\[
A_{\parallel} = \{P,FF,FL\}
\tag{4}\]</span></span></p>
<p>For the perpendicular case we 62 combinations, these are illustrated in <a href="#eq-perpendicular-combinations">Equation&nbsp;5</a>.</p>
<p><span id="eq-perpendicular-combinations"><span class="math display">\[
S_{\perp} = \Biggl\{ \left[{000\atop{000}}\right],
\left[{000\atop{001}}\right],
\left[{000\atop{010}}\right] ...
\left[{001\atop{001}}\right],
\left[{001\atop{010}}\right]...
\left[{110\atop{011}}\right]
\Biggr\}
\tag{5}\]</span></span></p>
<p>The action space is limited to flipping one out of three positions, First, Middle, Last, either Up of Down. Illustrated in <a href="#eq-action-space-perpendicular">Equation&nbsp;6</a>.</p>
<p><span id="eq-action-space-perpendicular"><span class="math display">\[
A_{\perp}=\{FU,MU,LU,FD,MD,LD\}
\tag{6}\]</span></span></p>
</section>
</section>
<section id="caveats" class="level3">
<h3 class="anchored" data-anchor-id="caveats">Caveats</h3>
<p>The windowed approach proposed above, along with the one-type-at-a-time technique reduce our <span class="math inline">\(A\)</span> and <span class="math inline">\(S\)</span> to magnitudes that are manageable and allow us to generate a training set. They do limit the potential for the agent in some non-trivial ways, namely:</p>
<ol type="1">
<li>The Agent will only look for combinations of three tiles, and</li>
<li>The agent will only look one move ahead.</li>
</ol>
<p>In view of (2) the more precise description of our endevour is perhaps to say that we are teaching it <em>tactics</em> rather than <em>strategy</em>.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>